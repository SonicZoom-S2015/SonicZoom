
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - shapes</title>
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="three.min.js"></script>

		<script type="text/javascript">
		var container, stats;

		var camera, scene, renderer, splineCamera, cameraEye;

		var text, plane;

		var targetRotation = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		var binormal = new THREE.Vector3();
		var normal = new THREE.Vector3();

		var points = [];
		var points2 = [];
		var points3 = [];

		var randomVertex;

        var prevPoint = new THREE.Vector3(0, 0, 0);
		var increment = 0;
        for (var i = 0; i < 50; i++){
            var randomX = prevPoint.x + 15;// + Math.round(Math.random() * 1.5);
            var randomY = prevPoint.y + 15;// + Math.round(Math.random() * 1.5);
            var randomZ = prevPoint.z + 15;// + Math.round(Math.random() * 1.5);

            var midx = (randomX + prevPoint.x)/2; 
            var midy = (randomY + prevPoint.y)/2;
            var midz = (randomZ + prevPoint.z)/2;

			if(increment == 30){
				randomVertex = new THREE.Vector3(0,randomY, randomZ);
				firsttime = true;
			}
			increment++;
            prevPoint.x = randomX;
            prevPoint.y = randomY;
            prevPoint.z = randomZ;

            points.push(new THREE.Vector3(0, midy, midz));
            points.push(new THREE.Vector3(0, randomY, randomZ));
            points2.push(new THREE.Vector3(0, midy, midz-5));
            points2.push(new THREE.Vector3(0, randomY, randomZ-5));
            points3.push(new THREE.Vector3(0, midy, midz+5));
            points3.push(new THREE.Vector3(0, randomY, randomZ+5));
        }

		var spline55 = new THREE.SplineCurve3(points);
		var spline56 = new THREE.SplineCurve3(points2);
		var spline57 = new THREE.SplineCurve3(points3);	

		extrudePath = spline55;
		extrudePath2 = spline56;
		extrudePath3 = spline57;
		extrudePath4 = spline55;
		var s;
		//Init
		//Time
		var t;
		//Camera Position
		var pos;
		//Current location of camera
		var arrowDir = 0;

		var closed2 = true;
		//All three paths
		var parent, parent2, parent3;
		var tube, tubeMesh, tubeMesh2, tubeMesh3;
		var animation = false, lookAhead = false;
		var scale = 4;

		var cube;

		function addTube() {
			var segments = 100;

			var radiusSegments =3;
			if (tubeMesh) parent.remove(tubeMesh);

			tube = new THREE.TubeGeometry(extrudePath, segments, 2, radiusSegments, false);
			tube2 = new THREE.TubeGeometry(extrudePath2, segments, 2, radiusSegments, false);
			tube3 = new THREE.TubeGeometry(extrudePath3, segments, 2, radiusSegments, false);

			addGeometry(tube, 0xff00ff);

			addGeometry(tube2, 0xff00ff);

			addGeometry(tube3, 0xff00ff);

			setScale();

		}

		function setScale() {
			tubeMesh.scale.set( scale, scale, scale );
			tubeMesh2.scale.set( scale, scale, scale );
			tubeMesh3.scale.set(scale, scale, scale);
		}


		function addGeometry( geometry, color ) {
			// 3d shape
			if(!tubeMesh){
			tubeMesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [
				new THREE.MeshLambertMaterial({
					color: color
				}),
				new THREE.MeshBasicMaterial({
					color: 0x000000,
					opacity: 0.3,
					wireframe: true,
					transparent: true
			})]);
				parent.add( tubeMesh );
			} else if(!tubeMesh2) {
				tubeMesh2 = THREE.SceneUtils.createMultiMaterialObject( geometry, [
				new THREE.MeshLambertMaterial({
					color: color
				}),
				new THREE.MeshBasicMaterial({
					color: 0x000000,
					opacity: 0.3,
					wireframe: true,
					transparent: true
			})]);
			parent2.add( tubeMesh2 );
			} else {
				tubeMesh3 = THREE.SceneUtils.createMultiMaterialObject( geometry, [
				new THREE.MeshLambertMaterial({
					color: color
				}),
				new THREE.MeshBasicMaterial({
					color: 0x000000,
					opacity: 0.3,
					wireframe: true,
					transparent: true
			})]);
			parent3.add( tubeMesh3 );
			}
		}

		init();
		animate();
		animation = true;

		function init() {
			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);
			camera.position.set(0, 50, 500);

			scene = new THREE.Scene();

			var light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 0, 0, 1 );
			scene.add( light );

			parent = new THREE.Object3D();
			//parent.position.y = 100;
			scene.add( parent );

			parent2 = new THREE.Object3D();
			//parent2.position.y = 100;
			scene.add( parent2 );

			parent3 = new THREE.Object3D();
			//parent3.position.y = 100;
			scene.add( parent3 );

			var cubegeometry = new THREE.BoxGeometry( 1,1, 1 );
			var cubematerial = new THREE.MeshBasicMaterial({
				map: THREE.ImageUtils.loadTexture('cointex.bmp')
			});
			cube = new THREE.Mesh( cubegeometry, cubematerial );
			cube.position.x = -13;
			cube.position.y = randomVertex.y;
			cube.position.z = randomVertex.z;
			cube.scale.set(scale, scale, scale);
			scene.add( cube );

			//add tunnel
        	var tempgeom = new THREE.TubeGeometry(extrudePath4, 256, 12, 70, false);

        	var tempmaterial = new THREE.MeshNormalMaterial({transparent: false, opacity: 0.8, side:THREE.DoubleSide});

        	var tempmesh = new THREE.Mesh( tempgeom, tempmaterial );

        	tempmesh.scale.set( scale, scale, scale );
        	//tempmesh.position.y = 100;
        	scene.add(tempmesh);

			splineCamera = new THREE.PerspectiveCamera( 84, window.innerWidth / window.innerHeight, 0.01, 1000 );
			//How to add static objects?
			parent.add( splineCamera );

			addTube();

			//cameraEye = new THREE.Mesh( new THREE.SphereGeometry( 5 ), new THREE.MeshBasicMaterial( { color: 0xdddddd } ) );
			//parent.add( cameraEye );

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );

			document.onkeydown = checkKey;
			
		}

		function checkKey(e){
			// left arrow
		    if(e.keyCode == '37') {
		    	//alert("Left arrow");
		    	if(arrowDir == 0){
		    		pos = tube2.parameters.path.getPointAt( t );	
		    		arrowDir = 1;
		    	} else if (arrowDir == 2){
		    		pos = tube.parameters.path.getPointAt( t );
		    		arrowDir = 0;
		    	}	
           	}
    		else if (e.keyCode == '39') {
       			// right arrow
       			if(arrowDir == 0){
       				pos = tube3.parameters.path.getPointAt( t );
       				arrowDir = 2;	
       			} else if(arrowDir == 1){
       				pos = tube.parameters.path.getPointAt( t );
       				arrowDir = 0;
       			}
    		}
		}

		function animate() {
			requestAnimationFrame( animate );
			render();
		}

		function render() {
			var time = Date.now();
			var looptime = 20 * 1000;
			t = ( time % looptime ) / looptime;

			if(arrowDir == 0){
				pos = tube.parameters.path.getPointAt( t );
			} else if(arrowDir == 1){
				pos = tube2.parameters.path.getPointAt( t );
			} else if(arrowDir == 2){
				pos = tube3.parameters.path.getPointAt( t );
			}

			//cube.position = tube.parameters.path.getPointAt(t);
			//cube.position.y += 5;
			//cube.position.z += 5;
			pos.multiplyScalar( scale );

			// interpolation
			var segments = tube.tangents.length;
			var pickt = t * segments;
			var pick = Math.floor( pickt );
			var pickNext = ( pick + 1 ) % segments;

			binormal.subVectors( tube.binormals[ pickNext ], tube.binormals[ pick ] );
			binormal.multiplyScalar( pickt - pick ).add( tube.binormals[ pick ] );

			var dir = tube.parameters.path.getTangentAt( t );

			var offset = 15;

			normal.copy( binormal ).cross( dir );

			// We move on a offset on its binormal
			pos.add( normal.clone().multiplyScalar( offset ) );

			splineCamera.position.copy( pos );
			//cameraEye.position.copy( pos );

			// Camera Orientation 1 - default look at
			// splineCamera.lookAt( lookAt );

			// Using arclength for stablization in look ahead.
			var lookAt = tube.parameters.path.getPointAt( ( t + 30 / tube.parameters.path.getLength() ) % 1 ).multiplyScalar( scale );

			// Camera Orientation 2 - up orientation via normal
			if (!lookAhead)
			lookAt.copy( pos ).add( dir );
			splineCamera.matrix.lookAt(splineCamera.position, lookAt, normal);
			splineCamera.rotation.setFromRotationMatrix( splineCamera.matrix, splineCamera.rotation.order );

			parent.rotation.y += ( targetRotation - parent.rotation.y ) * 0.05;

			renderer.render( scene, animation === true ? splineCamera : splineCamera );
		}
	</script>
	</body>
</html>